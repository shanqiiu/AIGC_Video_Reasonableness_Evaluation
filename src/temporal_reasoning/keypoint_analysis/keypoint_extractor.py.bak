# -*- coding: utf-8 -*-
"""
关键点提取器 - 使用最新MediaPipe API
支持PoseLandmarker和Holistic模型
"""

import os
import numpy as np
from typing import Dict, Optional
from pathlib import Path
import warnings
import urllib.request

warnings.filterwarnings("ignore")

# MediaPipe官方模型下载URL
DEFAULT_MODEL_URL = "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_heavy/float16/1/pose_landmarker_heavy.task"
# Holistic模型URL（如果新API支持，否则使用旧API）
HOLISTIC_MODEL_URL = "https://storage.googleapis.com/mediapipe-models/holistic_landmarker/holistic_landmarker/float16/1/holistic_landmarker.task"


class MediaPipeKeypointExtractor:
    """基于MediaPipe的关键点提取器（支持PoseLandmarker和Holistic）"""
    
    def __init__(self, model_path: Optional[str] = None, cache_dir: str = ".cache"):
        """
        初始化MediaPipe关键点提取器
        
        Args:
            model_path: .task模型文件路径，如果为None则使用默认模型
                       如果路径包含'holistic'，将使用Holistic模型（支持身体+手部+面部）
            cache_dir: 模型缓存目录，默认为.cache
        """
        self.cache_dir = Path(cache_dir).absolute()
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 设置MediaPipe缓存目录环境变量
        mediapipe_cache = self.cache_dir / "mediapipe"
        mediapipe_cache.mkdir(parents=True, exist_ok=True)
        os.environ['MEDIAPIPE_CACHE_DIR'] = str(mediapipe_cache)
        
        # 检测模型类型
        self.is_holistic = False
        if model_path:
            model_name = str(model_path).lower()
            self.is_holistic = 'holistic' in model_name
        
        # 模型路径处理
        if model_path:
            # 检查是否是URL
            if str(model_path).startswith(('http://', 'https://')):
                # 如果是URL，直接下载
                self.model_path = self._download_model(str(model_path), mediapipe_cache)
                # 检查下载的模型是否是holistic
                if 'holistic' in str(self.model_path).lower():
                    self.is_holistic = True
            else:
                # 如果是本地路径
                self.model_path = Path(model_path)
                if not self.model_path.exists():
                    # 文件不存在，根据模型类型选择默认URL
                    if self.is_holistic:
                        print(f"Holistic模型文件不存在: {model_path}")
                        print("尝试从默认URL下载Holistic模型...")
                        # 注意：如果新API不支持，将使用旧API的Holistic
                        try:
                            self.model_path = self._download_model(HOLISTIC_MODEL_URL, mediapipe_cache)
                        except:
                            # 如果下载失败，使用旧API（不需要.task文件）
                            self.model_path = None
                    else:
                        print(f"模型文件不存在: {model_path}")
                        print("尝试从默认URL下载PoseLandmarker模型...")
                        self.model_path = self._download_model(DEFAULT_MODEL_URL, mediapipe_cache)
        else:
            # 使用默认模型（PoseLandmarker）
            default_model_path = mediapipe_cache / "pose_landmarker_heavy.task"
            if not default_model_path.exists():
                print("默认模型文件不存在，正在从网络下载...")
                self.model_path = self._download_model(DEFAULT_MODEL_URL, mediapipe_cache)
            else:
                self.model_path = default_model_path
        
        self.landmarker = None
        self.holistic = None
        self.use_holistic = False
        self._initialize()
    
    def _initialize(self):
        """初始化MediaPipe模型"""
        if self.is_holistic:
            # 使用Holistic模型（优先尝试新API，失败则使用旧API）
            self._initialize_holistic()
        else:
            # 使用PoseLandmarker（新API）
            self._initialize_pose()
    
    def _initialize_holistic(self):
        """初始化Holistic模型"""
        # 首先尝试使用新API（如果支持）
        try:
            from mediapipe.tasks import python
            from mediapipe.tasks.python import vision
            from mediapipe import Image, ImageFormat
            
            # 检查是否有.task文件
            if self.model_path and self.model_path.exists():
                base_options = python.BaseOptions(
                    model_asset_path=str(self.model_path)
                )
            else:
                # 使用默认模型（MediaPipe会自动下载）
                base_options = python.BaseOptions()
            
            # 尝试使用HolisticLandmarker（如果新API支持）
            try:
                options = vision.HolisticLandmarkerOptions(
                    base_options=base_options,
                    running_mode=vision.RunningMode.VIDEO
                )
                self.landmarker = vision.HolisticLandmarker.create_from_options(options)
                self.mp_image = Image
                self.image_format = ImageFormat.SRGB
                self.use_holistic = True
                print(f"MediaPipe HolisticLandmarker（新API）初始化成功")
                return
            except AttributeError:
                # 新API不支持HolisticLandmarker，使用旧API
                print("新API不支持HolisticLandmarker，使用旧API的Holistic模型...")
                pass
        except ImportError:
            pass
        
        # 使用旧API的Holistic模型
        try:
            import mediapipe as mp
            
            self.mp_holistic = mp.solutions.holistic
            self.holistic = self.mp_holistic.Holistic(
                static_image_mode=False,
                model_complexity=2,
                enable_segmentation=False,
                refine_face_landmarks=True
            )
            self.use_holistic = True
            
            print("MediaPipe Holistic模型（旧API）初始化成功")
            print("支持检测：身体（33个）+ 手部（42个）+ 面部（468个）关键点")
            
        except ImportError as e:
            raise ImportError(
                f"MediaPipe未安装: {e}\n"
                "请安装MediaPipe: pip install mediapipe"
            )
        except Exception as e:
            raise RuntimeError(f"MediaPipe Holistic模型初始化失败: {e}")
    
    def _initialize_pose(self):
        """初始化PoseLandmarker模型（仅使用新API）"""
        try:
            from mediapipe.tasks import python
            from mediapipe.tasks.python import vision
            from mediapipe import Image, ImageFormat
            
            # 配置BaseOptions
            if self.model_path:
                base_options = python.BaseOptions(
                    model_asset_path=str(self.model_path)
                )
            else:
                # 使用默认模型（MediaPipe会自动下载到缓存目录）
                base_options = python.BaseOptions()
            
            # 配置PoseLandmarker选项
            options = vision.PoseLandmarkerOptions(
                base_options=base_options,
                output_segmentation_masks=False,
                running_mode=vision.RunningMode.VIDEO
            )
            
            # 创建PoseLandmarker
            self.landmarker = vision.PoseLandmarker.create_from_options(options)
            self.mp_image = Image
            self.image_format = ImageFormat.SRGB
            self.use_holistic = False
            
            model_info = str(self.model_path) if self.model_path else "默认模型"
            print(f"MediaPipe PoseLandmarker模型初始化成功: {model_info}")
            print(f"模型缓存目录: {os.environ.get('MEDIAPIPE_CACHE_DIR', '系统默认')}")
            print("注意: PoseLandmarker仅支持身体姿态检测（33个关键点）")
            
        except ImportError as e:
            raise ImportError(
                f"MediaPipe新API不可用: {e}\n"
                "请确保已安装最新版本的MediaPipe: pip install mediapipe>=0.10.0"
            )
        except Exception as e:
            raise RuntimeError(
                f"MediaPipe初始化失败: {e}\n"
                "请确保MediaPipe版本>=0.10.0，并检查模型文件路径是否正确"
            )
    
    def extract_keypoints(self, image: np.ndarray) -> Dict:
        """
        提取关键点
        
        Args:
            image: 输入图像 (H, W, 3) RGB，范围[0, 255]，uint8类型
        
        Returns:
            关键点字典，包含：
            - body: 身体关键点 (N, 3) 或 None
            - left_hand: 左手关键点 (N, 3) 或 None
            - right_hand: 右手关键点 (N, 3) 或 None
            - face: 面部关键点 (N, 3) 或 None
        """
        if self.use_holistic:
            return self._extract_keypoints_holistic(image)
        else:
            return self._extract_keypoints_pose(image)
    
    def _extract_keypoints_holistic(self, image: np.ndarray) -> Dict:
        """使用Holistic模型提取关键点（支持身体+手部+面部）"""
        # 如果使用新API的HolisticLandmarker
        if self.landmarker is not None and hasattr(self.landmarker, 'detect_for_video'):
            try:
                # 确保图像格式正确
                if image.dtype != np.uint8:
                    image = (image * 255).astype(np.uint8) if image.max() <= 1.0 else image.astype(np.uint8)
                
                if not image.flags['C_CONTIGUOUS']:
                    image = np.ascontiguousarray(image)
                
                mp_image = self.mp_image(
                    image_format=self.image_format,
                    data=image
                )
                
                detection_result = self.landmarker.detect_for_video(mp_image, timestamp_ms=0)
                
                keypoints = {
                    'body': None,
                    'left_hand': None,
                    'right_hand': None,
                    'face': None
                }
                
                # 提取所有关键点（新API格式）
                if hasattr(detection_result, 'pose_landmarks') and detection_result.pose_landmarks:
                    keypoints['body'] = np.array([
                        [lm.x, lm.y, lm.z] for lm in detection_result.pose_landmarks[0]
                    ])
                if hasattr(detection_result, 'face_landmarks') and detection_result.face_landmarks:
                    keypoints['face'] = np.array([
                        [lm.x, lm.y, lm.z] for lm in detection_result.face_landmarks[0]
                    ])
                if hasattr(detection_result, 'left_hand_landmarks') and detection_result.left_hand_landmarks:
                    keypoints['left_hand'] = np.array([
                        [lm.x, lm.y, lm.z] for lm in detection_result.left_hand_landmarks[0]
                    ])
                if hasattr(detection_result, 'right_hand_landmarks') and detection_result.right_hand_landmarks:
                    keypoints['right_hand'] = np.array([
                        [lm.x, lm.y, lm.z] for lm in detection_result.right_hand_landmarks[0]
                    ])
                
                return keypoints
            except Exception as e:
                print(f"警告: HolisticLandmarker（新API）提取失败，尝试使用旧API: {e}")
                # 如果新API失败，尝试使用旧API
                pass
        
        # 使用旧API的Holistic模型
        if self.holistic is None:
            return self._empty_keypoints()
        
        try:
            # 确保图像格式正确
            if image.dtype != np.uint8:
                image = (image * 255).astype(np.uint8) if image.max() <= 1.0 else image.astype(np.uint8)
            
            # 使用Holistic模型处理
            results = self.holistic.process(image)
            
            keypoints = {
                'body': None,
                'left_hand': None,
                'right_hand': None,
                'face': None
            }
            
            # 提取身体关键点（33个）
            if results.pose_landmarks:
                keypoints['body'] = np.array([
                    [lm.x, lm.y, lm.z] for lm in results.pose_landmarks.landmark
                ])
            
            # 提取手部关键点（每只手21个）
            if results.left_hand_landmarks:
                keypoints['left_hand'] = np.array([
                    [lm.x, lm.y, lm.z] for lm in results.left_hand_landmarks.landmark
                ])
            if results.right_hand_landmarks:
                keypoints['right_hand'] = np.array([
                    [lm.x, lm.y, lm.z] for lm in results.right_hand_landmarks.landmark
                ])
            
            # 提取面部关键点（468个）
            if results.face_landmarks:
                keypoints['face'] = np.array([
                    [lm.x, lm.y, lm.z] for lm in results.face_landmarks.landmark
                ])
            
            return keypoints
            
        except Exception as e:
            print(f"警告: 关键点提取失败（Holistic）: {e}")
            return self._empty_keypoints()
    
    def _extract_keypoints_pose(self, image: np.ndarray) -> Dict:
        """使用PoseLandmarker模型提取关键点（仅支持身体）"""
        if self.landmarker is None:
            return self._empty_keypoints()
        
        try:
            # 确保图像格式正确
            if image.dtype != np.uint8:
                image = (image * 255).astype(np.uint8) if image.max() <= 1.0 else image.astype(np.uint8)
            
            # 确保图像是连续的
            if not image.flags['C_CONTIGUOUS']:
                image = np.ascontiguousarray(image)
            
            # 转换为MediaPipe Image格式
            mp_image = self.mp_image(
                image_format=self.image_format,
                data=image
            )
            
            # 检测关键点
            detection_result = self.landmarker.detect_for_video(
                mp_image,
                timestamp_ms=0
            )
            
            # 提取关键点
            keypoints = {
                'body': None,
                'left_hand': None,
                'right_hand': None,
                'face': None
            }
            
            # 提取身体关键点（PoseLandmarker仅支持身体姿态）
            if detection_result.pose_landmarks:
                keypoints['body'] = np.array([
                    [lm.x, lm.y, lm.z] for lm in detection_result.pose_landmarks[0]
                ])
            
            # 注意：PoseLandmarker仅支持身体姿态检测（33个关键点）
            # 不支持手部和面部关键点
            
            return keypoints
            
        except Exception as e:
            print(f"警告: 关键点提取失败（PoseLandmarker）: {e}")
            return self._empty_keypoints()
    
    def _download_model(self, url: str, cache_dir: Path) -> Path:
        """
        从URL下载模型文件
        
        Args:
            url: 模型文件URL
            cache_dir: 缓存目录
        
        Returns:
            下载后的模型文件路径
        """
        # 从URL提取文件名
        filename = url.split('/')[-1].split('?')[0]  # 处理URL参数
        if not filename.endswith('.task'):
            filename = 'pose_landmarker_heavy.task'  # 默认文件名
        
        model_path = cache_dir / filename
        
        # 如果文件已存在，直接返回
        if model_path.exists():
            print(f"模型文件已存在: {model_path}")
            return model_path
        
        print(f"正在从 {url} 下载模型文件...")
        print(f"保存到: {model_path}")
        
        try:
            # 使用urllib下载文件，带进度条
            def show_progress(block_num, block_size, total_size):
                downloaded = block_num * block_size
                if total_size > 0:
                    percent = min(100, downloaded * 100 / total_size)
                    print(f"\r下载进度: {percent:.1f}% ({downloaded}/{total_size} bytes)", end='', flush=True)
            
            urllib.request.urlretrieve(url, model_path, reporthook=show_progress)
            print(f"\n模型下载完成: {model_path}")
            
            # 验证文件是否存在且大小合理
            if model_path.exists() and model_path.stat().st_size > 0:
                return model_path
            else:
                raise RuntimeError("下载的文件无效或为空")
                
        except Exception as e:
            # 如果下载失败，删除可能的不完整文件
            if model_path.exists():
                model_path.unlink()
            raise RuntimeError(
                f"模型下载失败: {e}\n"
                f"请检查网络连接，或手动下载模型文件到: {model_path}\n"
                f"下载URL: {url}"
            )
    
    def _empty_keypoints(self) -> Dict:
        """返回空的关键点字典"""
        return {
            'body': None,
            'left_hand': None,
            'right_hand': None,
            'face': None
        }
